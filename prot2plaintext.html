<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prot 2 Plaintext</title>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    height: 100vh;
    margin: 0;
    background-color: #f0f0f0;
  }
  .container {
    text-align: center;
    padding: 20px;
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }
  img {
    max-width: 100%;
    height: auto;
  }
  input[type="text"] {
    padding: 10px;
    margin-top: 20px;
    width: 300px;
    border-radius: 5px;
    border: 1px solid #ddd;
  }
  button {
    padding: 10px 20px;
    background-color: #007bff;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
  }
  button:hover {
    background-color: #0056b3;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Prot 2 Plaintext</h1>
  <img src="dna_gif.gif" alt="Biology GIF">
  <p>Enter the protocols.io Protocol Integer ID for the protocol you want to download as plaintext here:</p>
  <input type="text" id="protocolID" placeholder="Enter protocols.io Protocol Integer ID">
  <button onclick="processAndDownload()">Download as Plaintext</button>
</div>

<script>
async function processAndDownload() {
  const url = document.getElementById('protocolID').value;
  // Insert your URL processing and conversion logic here
  const protData = await protocolFromId('777c89643f8862bd3663cbecb8dd8be2f6053af3ed595268c38ee22888e16cfd46af648d7fc95fd87461bfdb56e01524821fdd9bda5ac6facfd33ec27070f993', url);
  
  // Example plaintext content, replace this with the actual content generated by your logic
  const plaintextContent = protocolDictToPlainText(protData);

  // Trigger the download
  downloadPlainText(plaintextContent, "protocol.txt");
}

function downloadPlainText(content, fileName) {
  const element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
  element.setAttribute('download', fileName);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

// Translates protocol_from_id function
async function protocolFromId(accessToken, protocolId) {
    const url = `https://www.protocols.io/api/v4/protocols/${protocolId}`;
    const headers = {
        "Authorization": `Bearer ${accessToken}`
    };

    try {
        const response = await fetch(url, { headers });
        if (response.ok) {
            const protocolData = await response.json();
            // Process the protocolData as needed here
            return protocolData;
        } else {
            console.error(`Failed to retrieve protocol. Status code: ${response.status}`);
        }
    } catch (error) {
        console.error('Error:', error);
    }
}

function protocolDictToPlainText(dataDict) {
    const data = dataDict.payload.steps;
    const unitMapping = Object.fromEntries(dataDict.payload.units.map(unit => [unit.id, unit.name]));

    data.forEach(step => {
        if (step.previous_id == null){
            step.previous_id = 0;
        }
    });

    const idToStep = Object.fromEntries(data.map(step => [step.id, step]));
    const previousIdToId = Object.fromEntries(data.filter(step => step.previous_id || step.previous_id === 0).map(step => [step.previous_id, step.id]));

    let sortedData = [];
    let currentId = previousIdToId[0];

    while (currentId in idToStep) {
        sortedData.push(idToStep[currentId]);
        currentId = previousIdToId[idToStep[currentId].id] || null;
    }

    let formattedSteps = "";
    let lastSectionName = null;
    let totalOffsetAdjustment = 0;
    sortedData.forEach((item, index) => {
        const stepInfo = JSON.parse(item.step);
        const block = stepInfo.blocks[0];
        let text = block.text;
        const entityMap = stepInfo.entityMap;

        block.entityRanges.sort((a, b) => a.offset - b.offset);
        block.entityRanges.forEach((entityRange, entityIndex) => {
            const entity = entityMap[String(entityRange.key)];
            let insertText = "";
            switch (entity.type) {
                case 'link':
                    insertText = `${entity.data.url} `;
                    break;
                case 'concentration':
                    const concentrationUnit = unitMapping[entity.data.unit] || '';
                    insertText = `${entity.data.concentration} ${concentrationUnit}`;
                    break;
                case 'temperature':
                    const temperatureUnit = unitMapping[entity.data.unit] || '';
                    insertText = `${entity.data.temperature} ${temperatureUnit}`;
                    break;
                case 'duration':
                    insertText = `${entity.data.duration} seconds`;
                    break;
                case 'centrifuge':
                    insertText = `${entity.data.centrifuge}x for ${entity.data.duration} seconds`;
                    break;
                default:
                    const volumeUnit = unitMapping[entity.data.unit] || '';
                    // Fallback for other types, similar handling as 'concentration'
                    insertText = `${entity.data.amount} ${volumeUnit} ${entity.data.label || ''}`;
                    break;
            }
            
            text = text.slice(0, entityRange.offset) + insertText + text.slice(entityRange.offset + entityRange.length);

            // Update offsets for subsequent entities
            for (let j = entityIndex + 1; j < block.entityRanges.length; j++) {
                block.entityRanges[j].offset += insertText.length - entityRange.length;;
            }
        });
        
        if (item.section !== null){
            const sectionName = item.section.replace('<p>', '').replace('</p>', '');
            if (sectionName !== lastSectionName) {
                formattedSteps += `Section: ${sectionName}\n`;
                lastSectionName = sectionName;
            }
        }

        formattedSteps += `Step ${index + 1}: ${text}\n\n`;
    });

    return formattedSteps;
}
</script>
</body>
</html>
